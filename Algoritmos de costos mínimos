package estructura.de.datos.ii;

import java.util.*;

public class Algotismosdecostosminimos {

    static class Edge implements Comparable<Edge> {
        int u, v, w; 
        Edge(int u, int v, int w) {
            this.u = u;
            this.v = v;
            this.w = w;
        }
        public int compareTo(Edge other) {
            return this.w - other.w; 
        }
    }

    static int V = 6; 
    static List<Edge> edges = new ArrayList<>();

    static int find(int[] parent, int i) {
        if (parent[i] == i) return i;
        return parent[i] = find(parent, parent[i]);
    }

    static void union(int[] parent, int[] rank, int x, int y) {
        int rx = find(parent, x), ry = find(parent, y);
        if (rx != ry) {
            if (rank[rx] < rank[ry]) parent[rx] = ry;
            else if (rank[rx] > rank[ry]) parent[ry] = rx;
            else { parent[ry] = rx; rank[rx]++; }
        }
    }

    static int kruskalMST() {
        Collections.sort(edges); 
        int[] parent = new int[V], rank = new int[V];
        for (int i=0; i<V; i++) parent[i] = i;

        int cost = 0, count = 0;
        for (Edge e : edges) {
            int ru = find(parent, e.u), rv = find(parent, e.v);
            if (ru != rv) { 
                cost += e.w;
                union(parent, rank, ru, rv);
                count++;
                System.out.println("Kruskal: tomo arista " + e.u + "-" + e.v + " (" + e.w + ")");
                if (count == V-1) break; 
            }
        }
        return cost;
    }

    static int primMST(List<List<Edge>> graph) {
        boolean[] visited = new boolean[V];
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        visited[0] = true; 
        pq.addAll(graph.get(0));

        int cost = 0, count = 1;
        while (!pq.isEmpty() && count < V) {
            Edge e = pq.poll();
            if (visited[e.v]) continue; 

            visited[e.v] = true;
            cost += e.w;
            count++;
            System.out.println("Prim: tomo arista " + e.u + "-" + e.v + " (" + e.w + ")");
            pq.addAll(graph.get(e.v));
        }
        return cost;
    }

    public static void main(String[] args) {
        // Aristas del grafo
        edges.add(new Edge(0,1,6));
        edges.add(new Edge(0,2,1));
        edges.add(new Edge(0,3,5));
        edges.add(new Edge(1,2,2));
        edges.add(new Edge(1,4,5));
        edges.add(new Edge(2,3,2));
        edges.add(new Edge(2,4,6));
        edges.add(new Edge(3,5,4));
        edges.add(new Edge(4,5,3));

 
        List<List<Edge>> graph = new ArrayList<>();
        for (int i=0; i<V; i++) graph.add(new ArrayList<>());
        for (Edge e : edges) {
            graph.get(e.u).add(new Edge(e.u, e.v, e.w));
            graph.get(e.v).add(new Edge(e.v, e.u, e.w));
        }

        System.out.println("---- Ejecutando Kruskal ----");
        int costKruskal = kruskalMST();

        System.out.println("\n---- Ejecutando Prim ----");
        int costPrim = primMST(graph);

        System.out.println("\nCosto total con Kruskal = " + costKruskal);
        System.out.println("Costo total con Prim = " + costPrim);
    }
}
